define(["exports", "require", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/legacy/polymer.dom.js", "./hax-shared-styles.js"], function (_exports, _require, _polymerElement, _polymerDom, _haxSharedStyles) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxContextItemMenu = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  /**
   * `hax-context-item-menu`
   * `An icon / button that has support for multiple options via drop down.`
   * @microcopy - the mental model for this element
   * - panel - the flyout from left or right side that has elements that can be placed
   * - button - an item that expresses what interaction you will have with the content.
   */
  class HaxContextItemMenu extends _polymerElement.PolymerElement {
    constructor() {
      super();
      new Promise((res, rej) => _require.default(["@lrnwebcomponents/hax-body/lib/hax-toolbar-menu.js"], res, rej));
      new Promise((res, rej) => _require.default(["@polymer/paper-tooltip/paper-tooltip.js"], res, rej));
      new Promise((res, rej) => _require.default(["@polymer/paper-item/paper-item.js"], res, rej));
      new Promise((res, rej) => _require.default(["@polymer/neon-animation/neon-animation.js"], res, rej));
    }

    static get template() {
      return _polymerElement.html`
      <style include="hax-shared-styles">
        :host {
          display: inline-flex;
          height: 36px;
          box-sizing: border-box;
        }
        :host hax-toolbar-menu ::slotted(*):hover {
          background-color: var(--hax-color-bg-accent);
        }
        :host hax-toolbar-menu ::slotted(*) {
          height: 36px;
        }
      </style>
      <hax-toolbar-menu
        id="menu"
        icon="[[icon]]"
        tooltip="[[label]]"
        tooltip-direction="[[direction]]"
        selected="{{selectedValue}}"
        reset-on-select="[[resetOnSelect]]"
      >
        <slot></slot>
      </hax-toolbar-menu>
    `;
    }

    static get tag() {
      return "hax-context-item-menu";
    }

    static get properties() {
      return {
        /**
         * Internal flag to allow blocking the event firing if machine selects tag.
         */
        _blockEvent: {
          type: Boolean,
          value: false
        },

        /**
         * Should we reset the selection after it is made
         */
        resetOnSelect: {
          type: Boolean,
          value: false
        },

        /**
         * Value.
         */
        selectedValue: {
          type: Number,
          reflectToAttribute: true,
          notify: true,
          value: 0,
          observer: "_selectedUpdated"
        },

        /**
         * Direction for the tooltip
         */
        direction: {
          type: String,
          value: "top"
        },

        /**
         * Icon for the button.
         */
        icon: {
          type: String,
          value: "editor:text-fields",
          reflectToAttribute: true
        },

        /**
         * Label for the button.
         */
        label: {
          type: String,
          value: "editor:text-fields",
          reflectToAttribute: true
        },

        /**
         * Name of the event to bubble up as being tapped.
         * This can be used to tell other elements what was
         * clicked so it can take action appropriately.
         */
        eventName: {
          type: String,
          value: "button",
          reflectToAttribute: true
        }
      };
    }
    /**
     * Notice the selected value has changed.
     */


    _selectedUpdated(newValue, oldValue) {
      if (typeof newValue !== typeof null && typeof oldValue !== typeof undefined && typeof oldValue !== typeof null) {
        let children = (0, _polymerDom.dom)(this).children;
        var item = new Object();
        var j = 0; // check for tag match since we have to filter out text nodes

        for (var i = 0, len = children.length; i < len; i++) {
          if (children[i].tagName === "PAPER-ITEM") {
            if (j === newValue) {
              item = children[i];
              len = i;
              continue;
            }

            j++;
          }
        } // ensure we have a value; if so, this becomes the event to look for
        // also use our flag to ensure machine setting the tag default doesn't
        // equate to firing off a selected event.


        if (!this._blockEvent && typeof item.attributes !== typeof undefined && typeof item.attributes.value !== typeof undefined && typeof item.attributes.value.value !== typeof undefined) {
          // weird but this makes the menu close when we send up an event
          // that indicates something higher should do something. This
          // avoids an annoying UX error where the menu stays open for
          // no reason.
          this.shadowRoot.querySelector("#menu").hideMenu();
          this.dispatchEvent(new CustomEvent("hax-context-item-selected", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              target: item,
              eventName: item.attributes.value.value
            }
          }));
        } // we only block 1 time if it's available


        if (this._blockEvent) {
          this._blockEvent = false;
        }
      }
    }

  }

  _exports.HaxContextItemMenu = HaxContextItemMenu;
  window.customElements.define(HaxContextItemMenu.tag, HaxContextItemMenu);
});